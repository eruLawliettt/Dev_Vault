#DeepCSharp 
[[Asynchronous Programming]]

## Введение в многопоточность. Класс Thread

Одним из ключевых аспектов в современном программировании является многопоточность. Ключевым понятием при работе с многоопоточностью является поток. Поток предствляет некоторую часть кода программы. При выполнении программы каждому потоку выделяется определенный квант времени. И при помощи многопоточности мы можем выделить в приложении несколько потоков, которые будут выполнять различные задачи одновременно. Если у нас, допустим, графическое приложение, которое посылает запрос к какому-нибудь серверу или считывает и обрабатывает огромный файл, то без многопоточности у нас бы блокировался графический интерфейс на время выполнения задачи. А благодаря потокам мы можем выделить отправку запроса или любую другую задачу, которая может долго обрабатываться, в отдельный поток. Поэтому, к примеру, клиент-серверные приложения (и не только они) практически не мыслимы без многопоточности.

Основной функционал для использования потоков в приложении сосредоточен в пространстве имен System.Threading. В нем определен класс, представляющий отдельный поток - класс Thread.

Класс Thread определяет ряд методов и свойств, которые позволяют управлять потоком и получать информацию о нем. Основные свойства класса:

- ExecutionContext: позволяет получить контекст, в котором выполняется поток
    
- IsAlive: указывает, работает ли поток в текущий момент
    
- IsBackground: указывает, является ли поток фоновым
    
- Name: содержит имя потока
    
- ManagedThreadId: возвращает числовой идентификатор текущего потока
    
- Priority: хранит приоритет потока - значение перечисления ThreadPriority:
    
    - Lowest
        
    - BelowNormal
        
    - Normal
        
    - AboveNormal
        
    - Highest
        
    
    По умолчанию потоку задается значение Normal. Однако мы можем изменить приоритет в процессе работы программы. Например, повысить важность потока, установив приоритет Highest. Среда CLR будет считывать и анализировать значения приоритета и на их основании выделять данному потоку то или иное количество времени.
    
- ThreadState возвращает состояние потока - одно из значений перечисления ThreadState:
    
    - Aborted: поток остановлен, но пока еще окончательно не завершен
        
    - AbortRequested: для потока вызван метод Abort, но остановка потока еще не произошла
        
    - Background: поток выполняется в фоновом режиме
        
    - Running: поток запущен и работает (не приостановлен)
        
    - Stopped: поток завершен
        
    - StopRequested: поток получил запрос на остановку
        
    - Suspended: поток приостановлен
        
    - SuspendRequested: поток получил запрос на приостановку
        
    - Unstarted: поток еще не был запущен
        
    - WaitSleepJoin: поток заблокирован в результате действия методов Sleep или Join


`Thread currentThread = Thread.CurrentThread;`

`Console.WriteLine(currentThread.Name);`
`currentThread.Name = "Main Method";`
`Console.WriteLine(currentThread.Name);`

`Console.WriteLine($"Запущен ли поток: {currentThread.IsAlive}");`

`Console.WriteLine($"Id потока: {currentThread.ManagedThreadId}");`

`Console.WriteLine($"Приоритет потока: {currentThread.Priority}");`

`Console.WriteLine($"Статус потока: {currentThread.ThreadState}");`

`for( int i = 0; i < 10; i++ )`
`{`
    `Thread.Sleep(500);`
    `Console.WriteLine(i);`
`}`

![[Pasted image 20240712191517.png]]



Язык C# позволяет запускать и выполнять в рамках приложения несколько потоков, которые будут выполняться одновременно.

Для создания потока применяется один из конструкторов класса Thread:

- Thread(ThreadStart): в качестве параметра принимает объект делегата ThreadStart, который представляет выполняемое в потоке действие
    
- Thread(ThreadStart, Int32): в дополнение к делегату ThreadStart принимает числовое значение, которое устанавливает размер стека, выделяемого под данный поток
    
- Thread(ParameterizedThreadStart): в качестве параметра принимает объект делегата ParameterizedThreadStart, который представляет выполняемое в потоке действие
    
- Thread(ParameterizedThreadStart, Int32): вместе с делегатом ParameterizedThreadStart принимает числовое значение, которое устанавливает размер стека для данного потока
    

Вне зависимости от того, какой конструктор будет применяться для создания, нам надо определить выполняемое в потоке действие. В этой статье рассмотрим использование делегата ThreadStart. Этот делегат представляет действие, которое не принимает никаких параметров и не возвращает никакого значения:

`public delegate void ThreadStart();`

//-----------------------------------------------------------------------------------------------

`Thread RedThread = new Thread(RedCounter);`
`RedThread.Start();`


`for( int i = 0; i < 5; i++ )`
`{`
    `Thread.Sleep(300);`
    `Console.WriteLine("Первый поток: " + i);`
`}`


`void RedCounter()`
`{`
    `for( int i = 0; i < 5 ;i++ )`
    `{`
        `Thread.Sleep(400);`
        `Console.WriteLine("Second thread: " + i);`   
    `}`
    
`}`

//-----------------------------------------------------------------------------------------------

## Потоки с параметрами и ParameterizedThreadStart


В предыдущей статье было рассмотрено, как запускать в отдельных потоках методы без параметров. А что, если нам надо передать какие-нибудь параметры в поток?

Для этой цели используется делегат ParameterizedThreadStart, который передается в конструктор класса Thread:

1
public delegate void ParameterizedThreadStart(object? obj);
Применение делегата ParameterizedThreadStart во многом похоже на работу с ThreadStart. Рассмотрим на примере:

`using System.Threading;`
 
`// создаем новые потоки`
`Thread myThread1 = new Thread(new ParameterizedThreadStart(Print));`
`Thread myThread2 = new Thread(Print);`
`Thread myThread3 = new Thread(message => Console.WriteLine(message));`

`// запускаем потоки`
`myThread1.Start("Hello");`
`myThread2.Start("Привет");`
`myThread3.Start("Salut");`

`void Print(object? message) => Console.WriteLine(message);`

При создании потока в конструктор класса Thread передается объект делегата ParameterizedThreadStart new Thread(new ParameterizedThreadStart(Print)), либо непосредственно метод, который соответствует этому делегату (new Thread(Print)), в том числе в виде лямбда-выражения (new Thread(message => Console.WriteLine(message)))

Затем при запуске потока в метод Start() передается значение, которое передается параметру метода Print. И в данном случае мы получим следующий консольный вывод:

Salut
Hello
Привет
При использовании ParameterizedThreadStart мы сталкиваемся с ограничением: мы можем запускать во втором потоке только такой метод, который в качестве единственного параметра принимает объект типа object?. Поэтому если мы хотим использовать данные других типов, в самом методе необходимо выполнить приведение типов. Например:


`using System.Threading;`
 
`int number = 4;`
`// создаем новый поток`
`Thread myThread = new Thread(Print);`
`myThread.Start(number);    // n * n = 16`


`// действия, выполняемые во втором потокке`
`void Print(object? obj)`
`{`
    `// здесь мы ожидаем получить число`
    `if (obj is int n)`
    `{`
        `Console.WriteLine($"n * n = {n * n}");`
    `}`
`}`

в данном случае нам надо дополнительно привести переданное значение к типу int, чтобы его использовать в вычислениях.

Но что делать, если нам надо передать не один, а несколько параметров различного типа? В этом случае можно определить свои типы:

`using System.Threading;`
 
`Person tom = new Person("Tom", 37);`
`// создаем новый поток`
`Thread myThread = new Thread(Print);`
`myThread.Start(tom);`

`void Print(object? obj)`
`{`
    `// здесь мы ожидаем получить объект Person`
    `if (obj is Person person)`
    `{`
        `Console.WriteLine($"Name = {person.Name}");`
        `Console.WriteLine($"Age = {person.Age}");`
    `}`
`}`

record class Person(string Name, int Age);
Сначала определяем специальный класс Person, объект которого будет передаваться во второй поток, а в методе Main передаем его во второй поток.

Но тут опять же есть одно ограничение: метод Thread.Start не является типобезопасным, то есть мы можем передать в него любой тип, и потом нам придется приводить переданный объект к нужному нам типу. Для решения данной проблемы рекомендуется объявлять все используемые методы и переменные в специальном классе, а в основной программе запускать поток через ThreadStart. Например:

`using System.Threading;`
 
`Person tom = new Person("Tom", 37);`
`// создаем новый поток`
`Thread myThread = new Thread(tom.Print);`
`myThread.Start();`

`record class Person(string Name, int Age)`
`{`
    `public void Print()`
    `{`
        `Console.WriteLine($"Name = {Name}");`
        `Console.WriteLine($"Age = {Age}");`
    `}`
`}`

//-----------------------------------------------------------------------------------------------

`Thread currentThread = Thread.CurrentThread;`

`currentThread.Name = "Main Method";`
`Console.WriteLine(currentThread.Name);`


`Thread RedThread = new Thread(Print);`
`RedThread.Start(19);`


`for( int i = 0; i < 5; i++ )`
`{`
    `Thread.Sleep(300);`
    `Console.WriteLine("Первый поток: " + i);`
`}`

`void Print(object? obj)`
`{`
    `if (obj is int n)`
        `Console.WriteLine($"Результат вычисления {n} * {n} = " + n * n);`
    `else`
        `Console.WriteLine("Переданный объект не является Int");`
`}`

//-----------------------------------------------------------------------------------------------

#так_можно_но_нихуя_не_нужно 

Нередко в потоках используются некоторые разделяемые ресурсы, общие для всей программы. Это могут быть общие переменные, файлы, другие ресурсы.

Решение проблемы состоит в том, чтобы синхронизировать потоки и ограничить доступ к разделяемым ресурсам на время их использования каким-нибудь потоком. Для этого используется ключевое слово lock. Оператор lock определяет блок кода, внутри которого весь код блокируется и становится недоступным для других потоков до завершения работы текущего потока. Остальный потоки помещаются в очередь ожидания и ждут, пока текущий поток не освободит данный блок кода.

`int x = 0;`
`object locker = new();`

`for (int i = 1; i < 6; i++)`
`{`
    `Thread myThread = new(Print);`
    `myThread.Name = $"Поток {i}";`
    `myThread.Start();`
`}`


`void Print()`
`{`
    `lock (locker)`
    `{`
        `x = 1;`
        `for (int i = 1; i < 6; i++)`
        `{`
            `Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");`
            `x++;`
            `Thread.Sleep(100);`
        `}`
    `}`
`}`

//-----------------------------------------------------------------------------------------------

